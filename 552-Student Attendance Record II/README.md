## 题目分析：
给你一个整数n，求出长度为n的可获得奖励的出勤记录的种类数，对10^9+7取模，n不超过100000，在出勤记录中A代表缺勤，L代表迟到，P代表出勤，一个出勤记录是可获得奖励的当且仅当出勤记录中缺勤没有超过一次或者没有连续迟到超过两次。

### 解题思路（1）：
暴力枚举所有长度为n的出勤记录然后判断是否是可获得奖励的，这种方法时间复杂度为O(n\*3^n)，这个复杂度是无法接受的。

### 解题思路（2）：
用DFS的方式来构造出每个可获得奖励的出勤记录，搜索的过程中记下已经出现了几个A以及当前连续出现几个L，这种方法时间复杂度约为O(2^n)，还是无法接受。

### 解题思路（3）：
动态规划。用dp[i][j][k][l]表示一个长度为i的出勤记录，前面出现了j个A，最后k个记录都是L，最后一个记录是A(l=0)、L(l=1)、P(l=2)的种类数，这样根据第i个记录和第i-1个记录可以构造出如下转移方程：</br>
最后两个字母为PA：dp[i][1][0][0]+=dp[i-1][0][0][2]；</br>
最后两个字母为JA：dp[i][1][0][0]+=dp[i-1][0][1][1]+dp[i-1][0][2][1]；</br>
最后两个字母为PJ：dp[i][j][1][1]+=dp[i-1][j][0][2]；(j=0,1)</br>
最后两个字母为JJ：dp[i][j][2][1]+=dp[i-1][j][1][1]；(j=0,1)</br>
最后两个字母为AJ：dp[i][1][1][1]+=dp[i-1][1][0][0]；</br>
最后两个字母为PP：dp[i][j][0][2]+=dp[i-1][j][0][2]；(j=0,1)</br>
最后两个字母为JP：dp[i][j][0][2]+=dp[i-1][j][1][1]+dp[i-1][j][2][1]；(j=0,1)</br>
最后两个字母为AP：dp[i][1][0][2]+=dp[i-1][1][0][0]；</br>
<<<<<<< HEAD
<<<<<<< HEAD
初始化时dp[0][0][0][2]=1（可以看成在一串出勤记录前有一个未记录的P），其余都为0。最后的结果为所有的dp[n][i][j][k](i=0,1,j=0,1,2,k=0,1,2)求和并取模，时间复杂度可以看成是O(n)，另外dp数组第一维大小可以只开2，转移的时候第一维对2取模，这样可以大大缩小空间开销。
=======
初始化时dp[0][0][0][2]=1（可以看成在一串出勤记录前有一个未记录的P），其余都为0。最后的结果为所有的dp[n][i][j][k]求和并取模，其中i=0,1,j=0,1,2,k=0,1,2，时间复杂度可以看成是O(n)，另外dp数组第一维大小可以只开2，转移的时候第一维对2取模，这样可以大大缩小空间开销。
>>>>>>> 4adc3980038b34215c0bb99ea99cfdfe54a39110
=======
初始化时dp[0][0][0][2]=1（可以看成在一串出勤记录前有一个未记录的P），其余都为0。最后的结果为所有的dp[n][i][j][k]求和并取模，其中i=0,1,j=0,1,2,k=0,1,2，时间复杂度可以看成是O(n)，另外dp数组第一维大小可以只开2，转移的时候第一维对2取模，这样可以大大缩小空间开销。
>>>>>>> 7873c4aa37d5001fa47b2bc11d8a0217e080ca9f

下面举一个简单例子走一遍算法帮助理解：n=2。</br>
初始化：dp[0][0][0][2]=1，其余为0。</br>
i=1：</br>
最后两个字母为PA：dp[1][1][0][0]+=dp[0][0][0][2]，更新为1；</br>
最后两个字母为JA：dp[1][1][0][0]+=dp[0][0][1][1]+dp[0][0][2][1]，更新为0；</br>
最后两个字母为PJ：dp[1][0][1][1]+=dp[0][0][0][2]，更新为1；dp[1][1][1][1]+=dp[0][1][0][2]，更新为0；</br>
最后两个字母为JJ：dp[1][0][2][1]+=dp[0][0][1][1]，更新为0；dp[1][1][2][1]+=dp[0][1][1][1]，更新为0；</br>
最后两个字母为AJ：dp[1][1][1][1]+=dp[0][1][0][0]，更新为0；</br>
最后两个字母为PP：dp[1][0][0][2]+=dp[0][0][0][2]，更新为1；dp[1][1][0][2]+=dp[0][1][0][2]，更新为0；</br>
最后两个字母为JP：dp[1][0][0][2]+=dp[0][0][1][1]+dp[0][0][2][1]，更新为0；dp[1][1][0][2]+=dp[0][1][1][1]+dp[0][1][2][1]，更新为0；</br>
最后两个字母为AP：dp[1][1][0][2]+=dp[0][1][0][0]，更新为0；</br>
i=2：</br>
最后两个字母为PA：dp[0][1][0][0]+=dp[1][0][0][2]，更新为1；</br>
最后两个字母为JA：dp[0][1][0][0]+=dp[1][0][1][1]+dp[1][0][2][1]，更新为1；</br>
最后两个字母为PJ：dp[0][0][1][1]+=dp[1][0][0][2]，更新为1；dp[0][1][1][1]+=dp[1][1][0][2]，更新为0；</br>
最后两个字母为JJ：dp[0][0][2][1]+=dp[1][0][1][1]，更新为1；dp[0][1][2][1]+=dp[1][1][1][1]，更新为0；</br>
最后两个字母为AJ：dp[0][1][1][1]+=dp[1][1][0][0]，更新为1；</br>
最后两个字母为PP：dp[0][0][0][2]+=dp[1][0][0][2]，更新为1；dp[0][1][0][2]+=dp[1][1][0][2]，更新为0；</br>
最后两个字母为JP：dp[0][0][0][2]+=dp[1][0][1][1]+dp[1][0][2][1]，更新为1；dp[0][1][0][2]+=dp[1][1][1][1]+dp[1][1][2][1]，更新为0；</br>
最后两个字母为AP：dp[0][1][0][2]+=dp[1][1][0][0]，更新为1；</br>
最终结果为8。
