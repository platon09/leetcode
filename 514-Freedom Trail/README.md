## 题目分析：
给你一个字符串ring，上面的字母均匀分布在圆盘外环，还有一个字符串key，需要借助圆盘拼写出来。每次操作可以将圆盘外环顺时针或逆时针旋转一格，将12点方向的字母换成相邻的字母，或者按下圆盘中心的按钮，拼写出12点方向的字母，求拼写出字符串key的最小操作步数，两个字符串长度不超过100且不为空，题目保证key能用ring拼写出来。

### 解题思路：
动态规划。dp[i][j]表示拼写完key的第i-1个字母，按下按钮时12点方向的字母是ring的第j个字母时所花的最小步数，转移时枚举上一个字母拼写完时12点方向的字母，并且需要考虑这一步是顺时针还是逆时针转动的，因此有状态转移方程dp[i][j]=min(dp[i][j], dp[i-1][k]+min((j-k+lenr)%lenr,(k-j+lenr)%lenr)+1)，k=0,1…lenr-1，lenr为字符串ring的长度，注意如果ring[j]!=key[i-1]则不进行转移。初始化dp[0][0]=0，其余为无穷大，最终答案为min(dp[lenk][i]，i=0,1…lenr-1，lenk为字符串key的长度)。

下面举一个简单例子走一遍算法帮助理解：ring=”abcde”，key=”ad”。</br>
初始化：dp[0][0]=0，其余为无穷大；</br>
计算dp[1][0]，由于key[0]==ring[0]，进行转移：</br>
从dp[0][0]转移，最优为不转动圆盘，dp[1][0]更新为1；</br>
从dp[0][1]转移，最优为逆时针转动1格，dp[1][0]保持不变；</br>
从dp[0][2]转移，最优为逆时针转动2格，dp[1][0]保持不变；</br>
从dp[0][3]转移，最优为顺时针转动2格，dp[1][0]保持不变；</br>
从dp[0][4]转移，最优为顺时针转动1格，dp[1][0]保持不变；</br>
计算dp[1][1]，由于key[0]!=ring[1]，不进行转移；</br>
计算dp[1][2]，由于key[0]!=ring[2]，不进行转移；</br>
计算dp[1][3]，由于key[0]!=ring[3]，不进行转移；</br>
计算dp[1][4]，由于key[0]!=ring[4]，不进行转移；</br>
计算dp[2][0]，由于key[1]!=ring[0]，不进行转移；</br>
计算dp[2][1]，由于key[1]!=ring[1]，不进行转移；</br>
计算dp[2][2]，由于key[1]!=ring[2]，不进行转移；</br>
计算dp[2][3]，由于key[1]==ring[3]，进行转移：</br>
从dp[1][0]转移，最优为顺时针转动2格，dp[2][3]更新为4；</br>
从dp[1][1]转移，最优为逆时针转动2格，dp[2][3]保持不变；</br>
从dp[1][2]转移，最优为逆时针转动1格，dp[2][3]保持不变；</br>
从dp[1][3]转移，最优为不转动圆盘，dp[2][3]保持不变；</br>
从dp[1][4]转移，最优为顺时针转动1格，dp[2][3]保持不变；</br>
计算dp[2][4]，由于key[1]!=ring[4]，不进行转移；</br>
最终结果为min(dp[2][0…4])=4。
