## 题意分析
给定一组非负整数。玩家一拿走这组数字中的任意一端的数字，玩家二拿剩下的数字中的任意一端的数字，然后玩家一取数，依次轮换，直到所有的数字都被取完，取得的数字之和最大的玩家获胜。  
给定一组非负整数想要预测玩家一是否能赢，假设两个玩家的目标都是最大化得分。  
```cpp
例 1:
输入: [1, 5, 2]
输出: False
解释: 开始，玩家一可以选择1或者2，如果他选择2（或1），玩家二可以选择1（或2）和5。
若玩家二选择5，1（或者）2留给了玩家一。
因此玩家一的最终得分是1+2=3，玩家二是5。
玩家一不会赢。

例 2:
输入: [1, 5, 233, 7]
输出: True
解释: 玩家一先选择1，玩家二只能选择5或者7。
无论玩家二选择哪个数，玩家一总会选择233。
最后，玩家一有234分，而玩家二只有12分，因此玩家一可以赢。
```
注意：
1. 整数数组长度大于等于1，小于等于20.
2. 数组中的任意一个数字都是非负的，也不会超过10000000.
3. 如果两个玩家得分相同，玩家一胜出。

## 题解
### 解题思路（1）
可以使用回溯法，搜索所有可能的选择序列，有任何一个序列可以让玩家一的得分大于或者等于玩家二，返回`True`，否则返回`False`。  
这样做会重复计算子问题，时间复杂高比较高，但是可以通过记录子问题的值来优化。

### 解题思路（2）
借鉴记忆数组的思想，先计算子问题，再计算规模更大的问题，动态规划的思想。  
具体实现在`solution.cpp`中。  
给定整数数组`nums[0...n-1]`，令`dp[i][j]`表示先手取数的玩家在子数组`nums[i...j]`中可以得到的分数与后手取数的玩家在子数组中可以得到的分数之差的最大值。  

先计算子数组长度小于`L`的子问题，子数组长度为`L`的问题的解可以由长度小于`L`的子问题的结果直接推出：`若j-i+1=L, dp[i][j]=max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`。  

其中，`nums[i] - dp[i+1][j]`表示先手取数的玩家先取`nums[i]`与另一个玩家先手取`nums[i+1...j]`能得到的最大值之差，结果代表玩家如果先取`nums[i]`能得到的最好结果，`nums[j] - dp[i][j-1]`同理。  
若`dp[0][len(nums)-1]>=0`，返回`True`，否则返回`False`。  

**时间复杂度**  
填满`dp`数组的时间复杂度就是整体的时间复杂度`O(n^2)`,空间复杂度也是`O(n^2)`。