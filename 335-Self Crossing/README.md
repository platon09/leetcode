## 题目分析：
有一个包含n个正整数的数组x，你从(0,0)点出发，先向北走x[0]米，再向西走x[1]米，再向南走x[2]米，再向东走x[3]米，依次类推，即下一次走之前先逆时针转90度再走，在线性时间复杂度和O(1)的空间复杂度内求是否会存在一个点会经过多次。

### 解题思路：
很容易想到两种不会经过一个点多次的情况，一种是螺旋向外的轨迹，即数组奇数位和偶数位的元素分别是升序的，另一种是螺旋向内的轨迹，即数组奇数位和偶数位的元素分别是降序的，从这里我们也可以得出奇数位和偶数位分别先升序后降序的数组在多数情况下也是不会经过一个点多次的。因此我们可以对数组从前往后扫描，检查x[i]是否大于x[i-2]，如果不大于接下来就有可能出现经过一个点多次，即后面的x[i]与x[i-3]形成的轨迹交叉，对于后面的x[i]如果出现x[i]>=x[i-2]那就说明该轨迹和x[i-3]画出的轨迹交叉了，那就直接返回true，如果都扫完了还是没有返回那就说明整个轨迹不会经过一个点多次，返回false。需要注意两点：在第一次出现x[i]不大于x[i-2]的地方，如果i不小于4，则需要根据x[i]、x[i-2]、x[i-4]的值来判断x[i+1]会和x[i-2]还是x[i-4]交叉，如果x[i]+x[i-4]>=x[i-2]，则x[i+1]有可能和x[i-4]交叉，此时可以将x[i-1]更新成x[i-1]-x[i-3]以方便下次判断；当i=3时，如果x[i]==x[i-2]，那么x[i+1]是有可能和x[i-3]出现部分轨迹重合的情况，此时可以看成在x[i-3]之前还有一条长度为0的轨迹，情况就和前一种相同了。该算法对数组扫描一遍即可，且只需一个变量记录当前数组按奇偶数位是升序还是降序，时间复杂度为O(n)，空间复杂度为O(1)。

下面举一个简单例子走一遍算法帮助理解：[1,1,2,2,5,5,4,3]。</br>
初始时，序列处于升序状态；</br>
i=2，x[2]=2>x[0]=1，依旧升序；</br>
i=3，x[3]=2>x[1]=1，依旧升序；</br>
i=4，x[4]=5>x[2]=2，依旧升序；</br>
i=5，x[5]=5>x[3]=2，依旧升序；</br>
i=6，x[6]=4<x[4]=5，状态变为降序，由于x[6]+x[2]=6>x[4]=5，将x[5]更新为x[5]-x[3]=3；</br>
i=3，x[6]=3=x[5]=3，存在一个点经过多次，返回true；</br>
最终结果为true。
