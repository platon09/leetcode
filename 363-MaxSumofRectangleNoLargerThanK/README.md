## 题目分析：

给定一个矩阵和一个数字`k`。找到该矩阵的一个子矩阵, 使得子矩阵中的数字的和尽可能大, 且不超过`k`。返回该和。

### 解题思路
假设矩阵的宽与高分别为`m`, `n`, 其中`n < m`. 若`n > m`, 对矩阵进行转置操作。
我们可以`O(mn)`预处理出`sum(i, j)`表示以`(i, j)`为边界角的和。那么我们可以`O((mn)^2)`枚举子矩阵, `O(1)`得到子矩阵的和, 并与k进行比较。总的时间复杂度为`O((mn)^2)`。
我们有一个更优秀的做法。我们枚举子矩阵的左右边界, 再枚举子矩阵的下边界, 那么我们需要找到子矩阵的上边界, 使得构成的子矩阵的数字的和尽可能大, 且不超过`k`。我们可以用前缀和的思想将最顶端的边界到该边界的和记录下来, 那么相当于每次找大于等于`sum-k`(`sum`表示当前的前缀和)的最小前缀和, 再用上`set`, 则每次找上边界的复杂度我们可以降到`O(logm)`. 总的时间复杂度为`O(mn^2logm)`.

### 例子
以`matrix = [ [1,  0, 1], [0, -2, 3] ]`, `k = 2`为例.
首先, 我们转置矩阵, 得到`matrix = [ [1, 0], [0, -2], [1, 3] ]`.

当左边界`l = 0`, 右边界`r = 1`时, 得到`[1+0, 0-2, 1+3] = [1, -2, 4]`, 向量中的数字代表当前行的和。
`set`初始化为`{0}`, `ans = MIN_INT`.
枚举下边界:
枚举到`1`时, 和为`1`, 再`set`中找 `>= 1-2`的最小值, 找到`0`, `ans = max(ans, 1-0) = 1`, `set`中加入`1`, `set = {0, 1}`.
枚举到`-2`时, 和为`-1`, 再`set`中找 `>= -1-2`的最小值, 未找到, `set`中加入`-3`, `set = {-3, 0, 1}`.
枚举到`4`时, 和为`3`, 再`set`中找 `>= 3-2`的最小值, 找到`1`, `ans = max(ans, 3-1) = 2`, `set`中加入`3`, `set = {0, 1, 3}`.
故`l = 0`, `r = 1`时, `ans`的最优值为`2`.
`l`, `r`为其余情况时类似.