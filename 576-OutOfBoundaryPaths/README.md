## 题意分析
有一个球和，一个m行n列的网格。给定初始时球的坐标`(i,j)`，你可以按照四个方向（上下左右）中的任意一个移动这个球到相邻的格子中或者穿过网格的边界。最多只能移动`N`次，找出可以把球移动出网格的所有路径的数量。  
结果要取`1e9 + 7`的余数。  
注意：
1. 一旦把球移出边界，就不能再移动回来。
2. 网格的长度和高度在`[1,50]`之间。
3. 最大移动次数`N`在`[0,50]`之间。

## 题解
以网格内的任意一个位置开始，移动`N`次能移出网格边界的路径数目是
- “以这个位置所有相邻网格开始，移动`N-1`次能移出网格边界的路径数目之和”。  
- 如果相邻的网格在网格边界之外，这个相邻网格的路径数目为`1`。  

设`m`行`n`列的网格，其实坐标为`(I,J)`，最多移动`N`次  
- `dp[i][j][l]`表示从坐标`(i,j)`开始，移动`l`次能移出网格边界的路径数目。
- 先计算移动`N-1`次的路径数目，那么移动`N`次的路径数目为`dp[i][j][N] = dp[i-1][j][N-1] + dp[i+1][j][N-1] + dp[i][j-1][N-1] + dp[i][j+1][N-1]`
- 因为“如果相邻的网格在网格边界之外，这个相邻网格的路径数目为`1`”这个设定导致了移动`N`次的路径数目中包含了移动`N-1,N-2,...,1`次的数目，所以结果为`dp[I][J][N]`。

具体实现在`solution.cpp`中。

## 例子
### 例一
`m=2, n=2, N=2, i=0, j=0`  
因为相邻的网格在网格边界之外，这个相邻网格的路径数目为`1`，所以我们把边界之外的位置也加入到网格中，值都设置为`1`。
```cpp
初始的时候，移动次数为0
dp[0...3][0...3][0]=
1	1	1	1
1	0	0	1
1	0	0	1
1	1	1	1

移动次数为1时
dp[0...3][0...3][1]=
1	1	1	1
1	2	2	1
1	2	2	1
1	1	1	1

移动次数为2时
dp[0...3][0...3][2]=
1	1	1	1
1	6	6	1
1	6	6	1
1	1	1	1
```
最后的结果为`dp[0][0][2]=6`。  
### 例二
`m=1, n=3, N=3, i=0, j=1`  
因为相邻的网格在网格边界之外，这个相邻网格的路径数目为`1`，所以我们把边界之外的位置也加入到网格中，值都设置为`1`。
```cpp
初始的时候，移动次数为0
dp[0...2][0...4][0]=
1	1	1	1	1
1	0	0	0	1
1	1	1	1	1

移动次数为1时
dp[0...2][0...4][1]=
1	1	1	1	1
1	3	2	3	1
1	1	1	1	1

移动次数为2时
dp[0...2][0...4][2]=
1	1	1	1	1
1	5	8	5	1
1	1	1	1	1

移动次数为3时
dp[0...2][0...4][3]=
1	1	1	1	1
1	11	12	11	1
1	1	1	1	1
```
最后的结果为`dp[0][1][3]=12`。  